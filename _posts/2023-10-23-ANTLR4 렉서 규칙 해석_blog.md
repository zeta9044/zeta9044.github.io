---
layout: post
title: "ANTLR4 렉서 규칙 해석"
date: 2023-10-23
tags: [렉, 규칙, 해석]
categories: blog
---

## 사용자 입력:
> MultiLineMacro:
	'#' (~[\n]*? '\\' '\r'? '\n')+ ~ [\n]+ -> channel (HIDDEN);

Directive: '#' ~ [\n]* -> channel (HIDDEN); 이것은 antlr4의  lexer내용일부인데, 해석해줘.

## ChatGPT 응답:
> ANTLR4는 파서 생성기로, 주어진 문법 기술에 따라 언어의 파서와 렉서를 생성하는 데 사용됩니다. 제시된 내용은 ANTLR4의 렉서 규칙 일부입니다. 해석을 제공하겠습니다.

1. `MultiLineMacro` 규칙:
   ```
   '#' (~[\n]*? '\\' '\r'? '\n')+ ~ [\n]+ -> channel (HIDDEN);
   ```

   - `'#'`: 이 규칙이 `#` 문자로 시작한다는 것을 나타냅니다.
   - `(~[\n]*? '\\' '\r'? '\n')+`: 이 부분은 `#` 뒤에 나오는 문자열을 설명합니다.
     - `~[\n]`: 개행 문자 (`\n`)를 제외한 어떤 문자든지 매치됩니다.
     - `*?`: 이전 패턴 (`~[\n]`)이 0회 이상 나타날 수 있으며, 최소한의 매치를 찾습니다 (lazy quantifier).
     - `'\\' '\r'? '\n'`: 백슬래시 (`\`) 다음에 선택적으로 carriage return (`\r`)을 포함한 개행 문자 (`\n`)가 오는 패턴을 나타냅니다. 이는 통상적으로 줄이 연속되도록 하는 escape 패턴으로 볼 수 있습니다.
     - `+`: 이전 패턴 전체 (`~[\n]*? '\\' '\r'? '\n'`)이 1회 이상 반복됩니다.
   - `~ [\n]+`: 개행 문자 (`\n`)를 제외한 하나 이상의 문자와 매치됩니다.
   - `-> channel (HIDDEN)`: 이 패턴에 일치하는 텍스트는 HIDDEN 채널로 보내집니다. 이는 파싱 중에는 무시되지만 필요에 따라 후에 사용될 수 있습니다.

   전체적으로 볼 때, `MultiLineMacro`는 `#`로 시작하고, 이어서 백슬래시로 연결된 여러 줄의 텍스트를 포함한 다중 라인 주석과 같은 것을 나타내는 것처럼 보입니다.

2. `Directive` 규칙:
   ```
   '#' ~ [\n]* -> channel (HIDDEN);
   ```

   - `'#'`: 규칙이 `#` 문자로 시작한다는 것을 나타냅니다.
   - `~ [\n]*`: 개행 문자를 제외한 0회 이상의 문자와 매치됩니다.
   - `-> channel (HIDDEN)`: 이 패턴에 일치하는 텍스트는 HIDDEN 채널로 보내집니다.

   이 규칙은 `#`로 시작하고 그 라인의 끝까지 이어지는 텍스트를 나타내는 것처럼 보입니다.

결론적으로, 이 두 규칙은 주석이나 지시문 같은 것을 처리하는 데 사용될 것으로 보입니다.

## 사용자 입력:
> -> channel (HIDDEN): 이 패턴에 일치하는 텍스트는 HIDDEN 채널로 보내집니다. 이는 파싱 중에는 무시되지만 필요에 따라 후에 사용될 수 있습니다. 그런데, 사용할려면 어떻게 해야해?

## ChatGPT 응답:
> ANTLR에서 `channel (HIDDEN)`을 사용하면 해당 토큰은 기본 파서 동작에서는 무시됩니다. 그러나, 때로는 이런 "숨겨진" 토큰들에 접근해야 할 필요가 있을 수 있습니다. 예를 들어, 원래의 소스 코드 위치 정보를 유지하려거나 주석을 다른 용도로 분석하려 할 때 등이 있습니다.

숨겨진 토큰에 접근하려면 몇 가지 단계를 거쳐야 합니다:

1. **TokenStream의 인스턴스 얻기**: 
   보통, ANTLR는 `CommonTokenStream`을 사용해서 입력 소스에 대한 토큰 스트림을 생성합니다.

   ```java
   ANTLRLexer lexer = new ANTLRLexer(new ANTLRInputStream(input));
   CommonTokenStream tokens = new CommonTokenStream(lexer);
   ```

2. **숨겨진 채널로부터 토큰 얻기**: 
   `CommonTokenStream`의 `getHiddenTokensToLeft`와 `getHiddenTokensToRight` 메서드를 사용하여 숨겨진 토큰을 얻을 수 있습니다. 이 메서드들은 주어진 토큰 인덱스의 왼쪽이나 오른쪽에 있는 숨겨진 토큰 리스트를 반환합니다.

   ```java
   List<Token> hiddenToLeft = tokens.getHiddenTokensToLeft(tokenIndex, ANTLRParser.HIDDEN);
   ```

3. **토큰 다루기**: 
   얻은 토큰 리스트를 사용하여 원하는 작업을 수행할 수 있습니다. 예를 들면, 토큰의 텍스트 내용에 접근하거나, 토큰의 위치 정보를 사용할 수 있습니다.

이렇게 하면 ANTLR에서 숨겨진 채널의 토큰들을 접근하고 다룰 수 있습니다.

## 사용자 입력:
> 리스너에서는 상용못하겠네.

## ChatGPT 응답:
> 맞습니다. 리스너(listener)는 파서 트리를 순회할 때 사용되며, 주로 파서 트리의 노드에 진입하거나 떠날 때의 동작을 정의합니다. 리스너 메서드 내에서 기본적으로 숨겨진 채널의 토큰에 직접적으로 접근하는 기능은 제공되지 않습니다.

하지만, 리스너를 사용하면서도 숨겨진 채널의 토큰에 접근할 방법이 있습니다:

1. **리스너에 `CommonTokenStream` 전달하기**: 리스너의 생성자나 다른 메서드를 통해 `CommonTokenStream`의 인스턴스를 리스너에 전달합니다.

2. **리스너 내에서 `getHiddenTokensToLeft` 또는 `getHiddenTokensToRight` 사용하기**: 리스너의 메서드 내에서 해당 메서드를 사용하여 숨겨진 토큰을 얻습니다.

예제:

```java
public class MyListener extends ANTLRBaseListener {
    private CommonTokenStream tokens;

    public MyListener(CommonTokenStream tokens) {
        this.tokens = tokens;
    }

    @Override
    public void enterSomeRule(ANTLRParser.SomeRuleContext ctx) {
        Token startToken = ctx.getStart();
        List<Token> hiddenToLeft = tokens.getHiddenTokensToLeft(startToken.getTokenIndex(), ANTLRParser.HIDDEN);
        // ... 처리 코드 ...
    }
}
```

이 방식을 사용하면 리스너 내에서도 숨겨진 채널의 토큰에 접근하고 처리할 수 있습니다.

## 사용자 입력:
> 위에 코드에서 Right도 똑같은 방식인가?

## ChatGPT 응답:
> 네, 맞습니다. 위의 코드 예제에서 `getHiddenTokensToLeft` 메서드를 사용하여 주어진 토큰의 왼쪽에 있는 숨겨진 토큰들을 가져왔습니다. 만약 주어진 토큰의 오른쪽에 있는 숨겨진 토큰들을 가져오고 싶다면, `getHiddenTokensToRight` 메서드를 사용하면 됩니다.

예제:

```java
@Override
public void enterSomeRule(ANTLRParser.SomeRuleContext ctx) {
    Token startToken = ctx.getStart();
    
    // 왼쪽에 있는 숨겨진 토큰 가져오기
    List<Token> hiddenToLeft = tokens.getHiddenTokensToLeft(startToken.getTokenIndex(), ANTLRParser.HIDDEN);
    
    // 오른쪽에 있는 숨겨진 토큰 가져오기
    List<Token> hiddenToRight = tokens.getHiddenTokensToRight(startToken.getTokenIndex(), ANTLRParser.HIDDEN);
    
    // ... 처리 코드 ...
}
```

`getHiddenTokensToRight` 메서드도 마찬가지로 특정 토큰 인덱스의 오른쪽에 있는 숨겨진 토큰들을 리스트로 반환합니다. 따라서 위의 코드와 같은 방식으로 이 메서드를 사용하여 숨겨진 토큰에 접근하고 처리할 수 있습니다.

## 사용자 입력:
> 왼쪽, 오른쪽 기준이 뭐야?

## ChatGPT 응답:
> ANTLR에서의 "왼쪽"과 "오른쪽" 기준은 토큰 스트림 내에서의 토큰의 위치를 의미합니다.

토큰 스트림은 소스 코드를 읽어들여 각각의 토큰으로 분리한 후 순서대로 저장하는 구조입니다. 이때, 각 토큰은 스트림 내에서 고유한 인덱스를 가집니다.

예를 들어, 다음과 같은 코드가 있다고 생각해봅시다:

```
int x = 10; // This is a comment
```

위 코드를 토큰화하면 다음과 같은 토큰 스트림이 생성될 수 있습니다:

```
int, x, =, 10, ;, // This is a comment
```

이때, `=` 토큰의 왼쪽에 있는 토큰은 `x`이고, 오른쪽에 있는 토큰은 `10`입니다. 따라서 `getHiddenTokensToLeft`와 `getHiddenTokensToRight` 메서드를 사용할 때 해당 토큰의 인덱스를 기준으로 스트림 내에서 왼쪽 또는 오른쪽에 있는 숨겨진 토큰들을 가져올 수 있습니다.

간단히 말해, "왼쪽"은 주어진 토큰의 이전 토큰들을, "오른쪽"은 주어진 토큰의 이후 토큰들을 의미합니다.

## 사용자 입력:
>     @Override
    public void enterTranslationUnit(CPP14Parser.TranslationUnitContext ctx) {
        Token startToken = ctx.getStart();
        List<Token> hiddenToLeft = tokens.getHiddenTokensToLeft(startToken.getTokenIndex(), ANTLRParser.HIDDEN);
        List<Token> hiddenToRight = tokens.getHiddenTokensToRight(startToken.getTokenIndex(), ANTLRParser.HIDDEN);

    }
그러면, 위에 코드 해석해줘.

## ChatGPT 응답:
> 해당 코드는 ANTLR의 리스너를 사용하는 예제 중 일부로 보입니다. 여기서는 C++의 문법에 따라 파싱된 결과 중 `TranslationUnit`이라는 규칙에 진입할 때 실행되는 동작을 정의하고 있습니다. 아래에서 코드를 단계별로 해석해드리겠습니다.

```java
@Override
public void enterTranslationUnit(CPP14Parser.TranslationUnitContext ctx) {
```

- `@Override`: Java의 애노테이션으로, 상위 클래스나 인터페이스의 메서드를 오버라이드(재정의)한다는 것을 나타냅니다.
  
- `enterTranslationUnit`: `TranslationUnit`이라는 규칙에 진입할 때 호출되는 리스너 메서드입니다. 즉, 파싱 중에 `TranslationUnit`에 해당하는 문법 구조가 발견되면 이 메서드가 자동으로 호출됩니다.
  
- `CPP14Parser.TranslationUnitContext ctx`: 파싱된 `TranslationUnit`에 대한 컨텍스트 정보를 포함하는 객체입니다. 이 객체는 해당 규칙에 관련된 여러 정보와 메서드를 제공합니다.

```java
Token startToken = ctx.getStart();
```

- `ctx.getStart()`: `TranslationUnitContext` 객체에서 현재 규칙이 시작하는 토큰을 가져옵니다. 이 토큰은 `TranslationUnit`에 해당하는 부분의 첫 번째 토큰입니다.

- `Token startToken`: 가져온 시작 토큰을 저장하는 변수입니다.

```java
List<Token> hiddenToLeft = tokens.getHiddenTokensToLeft(startToken.getTokenIndex(), ANTLRParser.HIDDEN);
```

- `tokens.getHiddenTokensToLeft(startToken.getTokenIndex(), ANTLRParser.HIDDEN)`: 시작 토큰의 왼쪽에 있는, 즉 시작 토큰 이전의 숨겨진 토큰들을 가져옵니다. 여기서 `HIDDEN` 채널의 토큰만을 대상으로 합니다.
  
- `List<Token> hiddenToLeft`: 왼쪽의 숨겨진 토큰들을 저장하는 리스트 변수입니다.

```java
List<Token> hiddenToRight = tokens.getHiddenTokensToRight(startToken.getTokenIndex(), ANTLRParser.HIDDEN);
```

- `tokens.getHiddenTokensToRight(startToken.getTokenIndex(), ANTLRParser.HIDDEN)`: 시작 토큰의 오른쪽에 있는, 즉 시작 토큰 이후의 숨겨진 토큰들을 가져옵니다. 여기서도 `HIDDEN` 채널의 토큰만을 대상으로 합니다.

- `List<Token> hiddenToRight`: 오른쪽의 숨겨진 토큰들을 저장하는 리스트 변수입니다.

이 코드는 `TranslationUnit`에 진입할 때 그 위치의 앞뒤로 있는 숨겨진 토큰들을 가져와서 저장하는 작업을 수행합니다. 이렇게 가져온 토큰들은 후속 처리나 분석에 사용될 수 있습니다.

## 사용자 입력:
> antlr4에서 토큰이름을 알려면?

## ChatGPT 응답:
> ANTLR4에서 토큰의 이름을 얻으려면 여러 방법이 있습니다. 가장 일반적인 방법은 파서와 렉서가 생성한 `Vocabulary` 객체를 사용하는 것입니다.

먼저, ANTLR4로부터 생성된 파서와 렉서 클래스에서 `Vocabulary` 객체를 얻을 수 있습니다. 이 객체는 토큰 타입과 토큰 이름 사이의 매핑을 제공합니다.

아래는 토큰 이름을 얻는 방법에 대한 예제입니다:

```java
// 예제: ANTLR4로부터 생성된 파서와 렉서 인스턴스를 생성
YourLexer lexer = new YourLexer(new ANTLRInputStream(input));
YourParser parser = new YourParser(new CommonTokenStream(lexer));

// Vocabulary 객체를 얻음
Vocabulary vocabulary = parser.getVocabulary();

// 특정 토큰 타입에 대한 토큰 이름을 얻음
int tokenType = YourLexer.SOME_TOKEN; // 예를 들어 SOME_TOKEN이라는 토큰 타입을 사용
String tokenName = vocabulary.getSymbolicName(tokenType);

System.out.println(tokenName);
```

위의 예제에서 `YourLexer`와 `YourParser`는 ANTLR4로부터 생성된 렉서와 파서 클래스의 이름입니다. 그리고 `SOME_TOKEN`은 원하는 토큰 타입을 나타내는 예제 값입니다. 실제 코드에서는 특정 토큰 타입에 대응하는 이름을 사용하면 됩니다.

이 방법을 사용하면 ANTLR4에서 생성된 파서와 렉서를 통해 토큰의 이름을 쉽게 얻을 수 있습니다.

## 사용자 입력:
> CommonTokenStream에서는 알 수 없나?

## ChatGPT 응답:
> 네, `CommonTokenStream`에서도 토큰의 이름을 알 수 있습니다. `CommonTokenStream`은 토큰의 시퀀스를 저장하며, 각 토큰은 `Token` 인터페이스를 구현하는 객체입니다. 각 `Token` 객체는 토큰의 타입 (`getType()`)을 알려주는 메서드를 가지고 있습니다.

`CommonTokenStream`이 연결된 렉서의 `Vocabulary` 또는 토큰 이름을 반환하는 메서드를 사용하여 토큰 타입을 토큰 이름으로 변환할 수 있습니다.

아래는 `CommonTokenStream`을 사용하여 토큰 이름을 얻는 방법에 대한 예제입니다:

```java
YourLexer lexer = new YourLexer(new ANTLRInputStream(input));
CommonTokenStream tokenStream = new CommonTokenStream(lexer);

// 토큰 스트림에서 토큰들을 가져오기
List<Token> tokens = tokenStream.getTokens();

// Vocabulary 객체를 얻기
Vocabulary vocabulary = lexer.getVocabulary();

for (Token token : tokens) {
    int tokenType = token.getType();
    String tokenName = vocabulary.getSymbolicName(tokenType);
    System.out.println(tokenName + ": " + token.getText());
}
```

위 코드는 입력 스트림에서 토큰을 추출하고, 각 토큰의 타입을 기반으로 토큰의 이름을 `Vocabulary` 객체를 통해 얻어 출력하는 예제입니다.

## 사용자 입력:
> CPP14Lexer.tokenNames[left.getType()] 이건 안되나?

## ChatGPT 응답:
> `CPP14Lexer.tokenNames`는 ANTLR 3에서의 방식으로, ANTLR 4에서는 이 방식이 제거되었습니다. 따라서, ANTLR 4를 사용하고 있다면 위의 방식으로는 토큰 이름을 직접 얻을 수 없습니다.

대신 ANTLR 4에서는 `Vocabulary` 객체를 사용하여 토큰 이름을 얻습니다. 위에서 설명한 `lexer.getVocabulary().getSymbolicName(tokenType)` 방식을 사용해야 합니다.

따라서 ANTLR 4 기반의 `CPP14Lexer`에서 토큰 이름을 얻으려면:

```java
String tokenName = CPP14Lexer.VOCABULARY.getSymbolicName(tokenType);
```

이렇게 `VOCABULARY` 객체를 사용하여 토큰 이름을 조회해야 합니다.

