---
layout: post
title: "문법 확장 충돌 해결 방법"
tags: [확장, 충돌, 해결, 방법, 문법]
---

## 사용자 입력:
> Warning: Choice conflict involving two expansions at
         line 278, column 5 and line 278, column 36 respectively.
         A common prefix is: <Identifier> "<"
         Consider using a lookahead of 3 or more for earlier expansion. 이 내용은 정확히 어떻게 하란 건지 한글로 알려줘.

## ChatGPT 응답:
> 물론이죠! 해당 경고 메시지는 파싱 오류와 관련되어 있는 것으로 보입니다. 여기서는 두 확장이 동일한 위치에서 발생하고 있으며, 이로 인해 해석의 모호성이 생긴 것입니다. 이를 한국어로 자세히 설명해 드리겠습니다.

이 경고는 두 개의 문법 확장이 충돌하고 있다는 것을 나타냅니다. 특히, 코드의 278번째 줄에서 같은 위치에서 두 가지 다른 확장이 가능한 상황입니다. 즉, 문법 분석기가 해당 위치에서 어떤 규칙을 적용해야 할지 판단할 수 없는 상황이 발생한 것입니다.

해결 방법 중 하나로 경고에서 제시하는 것처럼, 이전 확장에 대해 룩어헤드(lookahead)를 3 이상 사용하는 것을 고려해 볼 수 있습니다. 룩어헤드란 문법 분석기가 앞으로 몇 개의 토큰을 미리 볼 수 있는지를 나타내는 값입니다. 룩어헤드를 늘리면 문법 분석기가 더 많은 정보를 보고 정확한 결정을 내릴 수 있게 되므로 이런 충돌 문제를 해결할 수 있습니다.

이를 코드나 구체적인 문법에 적용하기 위해서는 문제가 발생하는 부분의 문맥과 규칙을 자세히 살펴보아야 할 것입니다.

## 사용자 입력:
> void idExpression() :
{
}
{
    unqualifiedId() | qualifiedId()
}

void unqualifiedId() :
{
}
{
    <Identifier>
    | operatorFunctionId()
    | conversionFunctionId()
    | literalOperatorId()
    | <Tilde> (className()|decltypeSpecifier())
    | templateId()
}

void qualifiedId() :
{
}
{
    nestedNameSpecifier() (<Template>)? unqualifiedId()
}  위에서 ne 278, column 5 and line 278, column 36  이 부분이 unqualifiedId() | qualifiedId() 인데, 어떻게 하란 건지 모르겠어.

## ChatGPT 응답:
> 문제가 되는 부분이 {% raw %}`unqualifiedId() | qualifiedId()`{% endraw %}에 있는 것이라면, 이 부분에서의 선택 구문이 어떻게 처리되어야 할지에 대한 모호성이 발생하고 있을 수 있습니다. 두 함수 간의 구분이 충분하지 않아서, 파서가 어떤 것을 선택해야 할지 결정할 수 없는 상황인 것 같습니다.

이 문제를 해결하기 위해 보다 구체적인 구분 기준을 마련해야 할 수도 있습니다. 현재 제공된 코드만으로는 전체 문맥을 파악하기 어려워 정확한 해결책을 제시하기가 어렵습니다만, 일반적으로 다음과 같은 방법들을 고려해 볼 수 있을 것입니다.

1. **룩어헤드 증가**: 이미 언급했던 것처럼, 룩어헤드를 증가시키면 문법 분석기가 더 많은 정보를 보고 정확한 결정을 내릴 수 있게 됩니다.

2. **규칙 재정의**: {% raw %}`unqualifiedId`{% endraw %}와 {% raw %}`qualifiedId`{% endraw %}의 정의를 좀 더 세분화하거나 명확하게 하여, 충돌을 제거할 수 있습니다. 두 함수 간에 어떤 특별한 순서나 조건이 있는지, 또는 특별한 토큰을 통해 구분할 수 있는지 확인해 볼 필요가 있을 것입니다.

3. **에러 메시지 분석**: 사용하고 있는 파서 도구가 제공하는 에러 메시지나 문서를 자세히 살펴보면, 이 문제를 어떻게 해결할 수 있는지에 대한 구체적인 가이드를 찾을 수도 있습니다.

4. **테스트와 디버깅**: 간단한 예제를 만들어 파싱을 시도하면서, 어떤 부분에서 충돌이 발생하는지 디버깅해 보는 것도 유용할 수 있습니다.

위 방법들을 조합하여 문제를 접근하면, 충돌 문제를 해결할 수 있을 것으로 기대됩니다.

## 사용자 입력:
> 룩어헤드를 적용한다면, 위에 코드에서 어떻게 하란 건지 모르겠어.

## ChatGPT 응답:
> 룩어헤드는 문법 분석기가 다음에 오는 토큰을 몇 개까지 미리 볼 수 있는지를 지정하는 값입니다. 일부 파싱 도구에서는 이 값을 직접 설정할 수 있으며, 이를 통해 문법의 모호성을 해결할 수 있습니다. 하지만, 제공하신 코드만으로는 어떤 파싱 도구를 사용하고 있는지 알 수 없기 때문에 특정 도구에 대한 구체적인 지시사항을 제공하기 어려워 보입니다.

일반적으로, 룩어헤드를 적용하기 위해서는 파서 생성 시에 룩어헤드 값을 설정해야 합니다. 예를 들어, JavaCC와 같은 도구를 사용하는 경우, .jj 파일 상단에서 {% raw %}`LOOKAHEAD`{% endraw %} 값을 설정할 수 있습니다.

{% raw %}```java
options {
    LOOKAHEAD = 3;
}
```{% endraw %}

ANTLR와 같은 도구에서는 문법 파일 내에서 특정 규칙에 대해 룩어헤드를 설정할 수 있을 것입니다.

만약 룩어헤드만으로 문제가 해결되지 않는다면, 그 대신 문법 자체를 재구조화하는 방법을 고려해야 할 수도 있습니다. {% raw %}`unqualifiedId`{% endraw %}와 {% raw %}`qualifiedId`{% endraw %} 사이의 구분을 더 명확하게 할 수 있는 방법을 찾아 적용하는 것이 좋을 것 같습니다.

최종적으로, 사용 중인 파싱 도구의 공식 문서나 커뮤니티를 참고하면, 해당 도구에서 룩어헤드를 어떻게 설정하고 사용하는지에 대한 구체적인 지침을 찾을 수 있을 것입니다.

## 사용자 입력:
> 파싱도구는 javaCC야. 어떻게 해야 해?

## ChatGPT 응답:
> JavaCC에서 룩어헤드를 설정하는 방법은 상황에 따라 달라질 수 있습니다. 복잡한 문법 구조에서 모호성을 해결하려면 특정 규칙에 대한 룩어헤드를 조정할 수 있습니다.

아래에는 일반적인 방법을 몇 가지 설명하겠습니다:

1. **전역 룩어헤드 설정**: 파일 상단에 전역적인 룩어헤드 값을 설정할 수 있습니다.

   {% raw %}```java
   options {
       LOOKAHEAD = 3;
   }
   ```{% endraw %}

2. **특정 규칙에 대한 룩어헤드 설정**: 특정 규칙에서만 룩어헤드를 변경하려면 규칙 정의 앞에 룩어헤드 값을 지정합니다.

   {% raw %}```java
   void idExpression() : 
   {
       LOOKAHEAD(3)
   }
   {
       unqualifiedId() | qualifiedId()
   }
   ```{% endraw %}

   이 예제에서는 {% raw %}`idExpression`{% endraw %} 규칙에 대해 룩어헤드 값을 3으로 설정했습니다.

3. **보다 정밀한 룩어헤드 제어**: 필요에 따라 특정 토큰을 미리 보도록 복잡한 룩어헤드 표현식을 작성할 수도 있습니다.

   {% raw %}```java
   void idExpression() : 
   {
       LOOKAHEAD(3) unqualifiedId() | LOOKAHEAD(3) qualifiedId()
   }
   {
   }
   ```{% endraw %}

룩어헤드 설정을 변경한 후에는 충돌 경고가 사라지는지 확인해 보세요. 룩어헤드만으로 문제가 해결되지 않는다면, 문법 규칙을 재조정해야 할 수도 있습니다. 해당 규칙이 어떻게 동작해야 하는지에 대한 문맥을 정확히 이해하고, {% raw %}`unqualifiedId`{% endraw %}와 {% raw %}`qualifiedId`{% endraw %} 간의 차이를 더 명확하게 표현해야 할 수도 있습니다.

JavaCC 문서나 튜토리얼을 참고하면 룩어헤드와 관련된 더 많은 옵션과 정보를 얻을 수 있을 것입니다.

