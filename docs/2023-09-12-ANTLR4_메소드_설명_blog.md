---
layout: post
title: "ANTLR4 메소드 설명"
date: 2023-09-12
tags: [메, 소드, 설명]
categories: blog
---

## 사용자 입력:
> ANTLR4의 ParserRuleContext에서 getPayLoad()와 getSourceInterval() 뭔지 알려줘.

## ChatGPT 응답:
> ANTLR4는 다양한 프로그래밍 언어에서 사용할 수 있는 파서 생성 도구입니다. ANTLR4로 생성된 파서에서 `ParserRuleContext`는 파싱된 문법 규칙에 해당하는 부분의 정보를 포함하는 클래스입니다.

1. **getPayload()**:
   - `getPayload()` 메소드는 해당 `ParserRuleContext`의 페이로드를 반환합니다.
   - 기본적으로 `ParserRuleContext`의 페이로드는 그 자체입니다 (즉, `this`를 반환). 이는 `Tree` 인터페이스의 일부입니다.
   - 그러나, 필요에 따라 사용자가 페이로드를 다른 객체로 설정하거나 사용할 수 있습니다. 일반적으로 ANTLR 사용자들은 이를 재정의하거나 변경하는 경우가 드뭅니다.

2. **getSourceInterval()**:
   - `getSourceInterval()` 메소드는 파싱된 텍스트 내에서 해당 규칙이 차지하는 인덱스의 범위를 반환합니다.
   - 반환 값은 `Interval` 객체로, 이는 문법 규칙이 시작되는 인덱스와 끝나는 인덱스를 포함합니다.
   - 이 정보는 디버깅, 오류 메시지 생성, 소스 코드 하이라이팅 등의 작업에서 유용하게 사용될 수 있습니다.

이 두 메소드는 ANTLR4의 파싱 트리와 관련된 메타 데이터 정보를 제공하는 데 유용합니다. 그러나 일반적인 사용 사례에서는 이러한 메소드를 직접 호출하는 경우가 드뭅니다. 대부분의 사용자는 파싱된 트리를 탐색하거나, 변환하거나, 다른 작업을 수행하는데 집중합니다.

## 사용자 입력:
> 예제보여줘봐.

## ChatGPT 응답:
> 물론이죠. ANTLR4를 사용하여 간단한 문법을 정의하고, 그 문법을 파싱하여 `ParserRuleContext`의 `getPayload()` 및 `getSourceInterval()` 메소드를 사용하는 예제를 제공하겠습니다.

1. 먼저 간단한 문법을 정의합니다. 예를 들어, 두 개의 숫자를 더하는 문법을 생각해보겠습니다. 이 문법을 `SimpleMath.g4`라는 파일에 저장합니다.

```antlr
grammar SimpleMath;

// Parser rules
expr: NUMBER '+' NUMBER;

// Lexer rules
NUMBER: [0-9]+;
WS: [ \t\r\n]+ -> skip;
```

2. ANTLR4를 사용하여 파서 및 렉서를 생성합니다.

```bash
antlr4 SimpleMath.g4
javac SimpleMath*.java
```

3. 이제 Java에서 ANTLR4 파서를 사용하여 텍스트를 파싱하고 `getPayload()` 및 `getSourceInterval()` 메소드를 호출하는 예제 코드를 작성합니다.

```java
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;

public class TestSimpleMath {
    public static void main(String[] args) {
        String input = "3 + 5";
        SimpleMathLexer lexer = new SimpleMathLexer(CharStreams.fromString(input));
        SimpleMathParser parser = new SimpleMathParser(new CommonTokenStream(lexer));
        SimpleMathParser.ExprContext exprContext = parser.expr();

        System.out.println("Payload: " + exprContext.getPayload());
        System.out.println("Source Interval: " + exprContext.getSourceInterval());
    }
}
```

4. 위 코드를 실행하면, "3 + 5"라는 입력에 대한 `ParserRuleContext`의 페이로드와 소스 인터벌을 출력할 것입니다.

이러한 방식으로 ANTLR4와 Java를 사용하여 텍스트를 파싱하고, 파싱된 정보에 대한 메타 데이터를 얻을 수 있습니다.

## 사용자 입력:
> 출력값이 어떻게 나오는지도 보여줘야지.

## ChatGPT 응답:
> 죄송합니다. 실제 실행 환경이 여기에 없기 때문에 정확한 출력을 바로 보여드릴 수 없습니다. 그러나 위 예제를 기반으로 예상되는 출력을 설명해 드리겠습니다.

- `exprContext.getPayload()` 호출의 결과는 해당 `ParserRuleContext` 객체 자체입니다. 따라서 출력은 해당 객체의 기본 `toString()` 표현 (즉, 객체의 메모리 주소와 같은 정보)이 될 것입니다.
  
- `exprContext.getSourceInterval()` 호출의 결과는 "3 + 5"에서 `expr` 규칙이 차지하는 텍스트의 인덱스 범위를 나타내는 `Interval` 객체입니다. "3"은 인덱스 0에서 시작하고, "5"는 인덱스 4에서 끝나므로, 인터벌은 [0,4]가 될 것입니다.

따라서 예상 출력은 다음과 비슷하게 나올 것입니다:

```
Payload: [Lorg.antlr.v4.runtime.tree.ParseTree;@15db9742
Source Interval: [0,4]
```

여기서 "Payload"의 값은 실제 메모리 주소에 따라 다를 수 있습니다.

## 사용자 입력:
> ANTLR4의 ParserRuleContext에서 같은 depth를  찾아갈 수 있나?

## ChatGPT 응답:
> ANTLR4의 `ParserRuleContext`에는 자식 노드를 나타내는 `children` 리스트가 있습니다. 그러나, 같은 depth에서의 인접한 노드를 직접 찾아가는 메소드는 내장되어 있지 않습니다. 

하지만, 현재 `ParserRuleContext`가 부모의 `children` 리스트 내에서 어떤 위치에 있는지 알면, 같은 depth에서의 인접한 노드를 찾을 수 있습니다. 

다음은 같은 depth에서의 이전 노드와 다음 노드를 찾는 방법을 보여주는 간단한 코드입니다:

```java
public class ANTLRUtils {

    public static ParserRuleContext getPreviousSibling(ParserRuleContext ctx) {
        if (ctx.getParent() == null) return null;

        List<ParseTree> siblings = ctx.getParent().children;
        int index = siblings.indexOf(ctx);
        if (index > 0) {
            return (ParserRuleContext) siblings.get(index - 1);
        }
        return null;
    }

    public static ParserRuleContext getNextSibling(ParserRuleContext ctx) {
        if (ctx.getParent() == null) return null;

        List<ParseTree> siblings = ctx.getParent().children;
        int index = siblings.indexOf(ctx);
        if (index >= 0 && index < siblings.size() - 1) {
            return (ParserRuleContext) siblings.get(index + 1);
        }
        return null;
    }
}
```

위의 메소드들은 주어진 `ParserRuleContext`의 부모의 `children` 리스트 내에서 현재 `ctx`의 위치를 찾고, 그 기반으로 이전 또는 다음 노드를 반환합니다.

이 방법을 사용하면, 같은 depth에서의 인접한 노드를 찾을 수 있습니다.

## 사용자 입력:
> 위 내용에 같은 depth의 다른 ParserRuleContext를 찾는 메소드 추가해.

## ChatGPT 응답:
> 물론이죠. 같은 depth의 다른 `ParserRuleContext`를 찾기 위해서는, 현재 `ParserRuleContext`의 부모 노드에서 시작하여 같은 유형의 노드를 탐색하면 됩니다. 

다음은 같은 depth에서의 같은 유형의 `ParserRuleContext`를 찾는 메소드를 추가한 코드입니다:

```java
public class ANTLRUtils {

    public static ParserRuleContext getPreviousSibling(ParserRuleContext ctx) {
        if (ctx.getParent() == null) return null;

        List<ParseTree> siblings = ctx.getParent().children;
        int index = siblings.indexOf(ctx);
        while (index > 0) {
            index--;
            if (siblings.get(index).getClass().equals(ctx.getClass())) {
                return (ParserRuleContext) siblings.get(index);
            }
        }
        return null;
    }

    public static ParserRuleContext getNextSibling(ParserRuleContext ctx) {
        if (ctx.getParent() == null) return null;

        List<ParseTree> siblings = ctx.getParent().children;
        int index = siblings.indexOf(ctx);
        while (index >= 0 && index < siblings.size() - 1) {
            index++;
            if (siblings.get(index).getClass().equals(ctx.getClass())) {
                return (ParserRuleContext) siblings.get(index);
            }
        }
        return null;
    }
}
```

위의 코드에서 `getPreviousSibling`과 `getNextSibling` 메소드는 현재 `ctx`와 동일한 유형의 `ParserRuleContext`를 찾기 위해 현재 위치에서부터 이전 또는 다음으로 이동하면서 탐색합니다.

## 사용자 입력:
> 아냐..추가하라는건, 동일한 게 아니라, 동일 depth에서 내가 지정한  Rule을 찾는 걸 추가하라는 거야.

## ChatGPT 응답:
> 알겠습니다. 같은 depth에서 사용자가 지정한 규칙 타입의 `ParserRuleContext`를 찾는 메소드를 추가하겠습니다.

다음은 지정한 규칙 타입에 따라 같은 depth에서의 이전 또는 다음 `ParserRuleContext`를 찾는 메소드입니다:

```java
public class ANTLRUtils {

    public static ParserRuleContext getPreviousSibling(ParserRuleContext ctx) {
        if (ctx.getParent() == null) return null;

        List<ParseTree> siblings = ctx.getParent().children;
        int index = siblings.indexOf(ctx);
        if (index > 0) {
            return (ParserRuleContext) siblings.get(index - 1);
        }
        return null;
    }

    public static ParserRuleContext getNextSibling(ParserRuleContext ctx) {
        if (ctx.getParent() == null) return null;

        List<ParseTree> siblings = ctx.getParent().children;
        int index = siblings.indexOf(ctx);
        if (index >= 0 && index < siblings.size() - 1) {
            return (ParserRuleContext) siblings.get(index + 1);
        }
        return null;
    }

    public static <T extends ParserRuleContext> T getPreviousSiblingOfType(ParserRuleContext ctx, Class<T> ruleType) {
        if (ctx.getParent() == null) return null;

        List<ParseTree> siblings = ctx.getParent().children;
        int index = siblings.indexOf(ctx);
        while (index > 0) {
            index--;
            if (ruleType.isInstance(siblings.get(index))) {
                return ruleType.cast(siblings.get(index));
            }
        }
        return null;
    }

    public static <T extends ParserRuleContext> T getNextSiblingOfType(ParserRuleContext ctx, Class<T> ruleType) {
        if (ctx.getParent() == null) return null;

        List<ParseTree> siblings = ctx.getParent().children;
        int index = siblings.indexOf(ctx);
        while (index >= 0 && index < siblings.size() - 1) {
            index++;
            if (ruleType.isInstance(siblings.get(index))) {
                return ruleType.cast(siblings.get(index));
            }
        }
        return null;
    }
}
```

위의 코드에서 `getPreviousSiblingOfType`와 `getNextSiblingOfType` 메소드는 사용자가 지정한 규칙 타입 (`ruleType`)을 기반으로 현재 `ctx`와 같은 depth에서의 이전 또는 다음 `ParserRuleContext`를 찾습니다.

